# Golitex â†’ Lean 4 Port â€“ Upstream Component Analysis

> **Status:** Draft (2025-06-11) â€“ Generated by Codex session. Will be amended continuously.

This document catalogues the major packages/modules of the original [`golitex`](https://github.com/litexlang/golitex) Go code-base and maps them to their Lean-4 counterparts (either *to-be-written* or *irrelevant/do-not-port*).  The purpose is to identify clear work packages for subsequent porting phases.

---

## 1. High-level architecture of `golitex`

| Layer | Upstream Packages (Go) | Responsibility | Notes |
|-------|-----------------------|----------------|-------|
| **Lexing** | `token`, `scanner` | Convert UTF-8 text into a token stream (commands, arguments, braces, comments). | Pure functions w/ small state machine. |
| **Parsing** | `parser`, `ast` | Recursive-descent parser producing strongly-typed AST (`Node` interface with kinds). Handles macro invocation and environment constructs. | Separate macro expansion phase in Go impl â€“ we will fuse into Lean elaboration. |
| **Macro Expansion** | `expander`, `macro` | Looks up command definitions, substitutes arguments, produces enriched AST. | Relies on run-time table of macros; close match to Leanâ€™s macro system. |
| **Semantic Analysis** | `resolver`, `packages` | Checks references (`\ref`, counters, labels), package loading, option defaults. | Will map to Lean attributes / environment extensions. |
| **IR** | `core` | Language-neutral document tree (sections, para, etc.) used by renderers. | Keep the idea; re-implement as Lean inductive types. |
| **Renderers** | `pdf`, `html`, `xml` | Back-ends taking the IR to bytes on disk. | We will start with PDF & HTML. |
| **CLI / Tooling** | `cmd/golitex` | Command-line wrapper, file watcher, diagnostics. | Lake tasks will cover this. |

### Dependency graph (simplified)

```
scanner â†’ token â†˜        
                   parser â†’ ast â”€â”  
                                   â†’ expander â†’ core â†’ {pdf,html,xml}
packages â†’ resolver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Mapping table: Go package â†’ Lean 4 module

| Go Package | Porting Strategy | Lean Module Namespace | Blocking Dependencies |
|------------|-----------------|-----------------------|-----------------------|
| `token`    | Translate as purely functional scanner producing `Token` inductive. | `Golitex.Frontend.Token` | None |
| `scanner`  | Re-implement using Lean byte arrays & `StateM`. | `Golitex.Frontend.Scanner` | `Token` |
| `ast`      | Map `interface` hierarchy to mutually-recursive inductives. | `Golitex.Frontend.AST` | `Token` |
| `parser`   | Drop: we will *not* write a generic parser â€“ Leanâ€™s `syntax`/`macro` system supersedes it. | â€“ | â€“ |
| `macro` / `expander` | Use Lean `macro_rules` & `elab_*`. | `Golitex.Elab.Macro` | `AST` |
| `core`     | Re-create as IR inductives. | `Golitex.IR` | `Elab` |
| `pdf`      | Keep algorithm, translate to Lean `IO` calling out to TeX engine. | `Golitex.Backend.PDF` | `IR` |
| `html`     | Same as PDF, but produce DOM. | `Golitex.Backend.HTML` | `IR` |
| `cmd/golitex` | Replace with Lake tasks. | `Golitex.CLI` | back-ends |

Legend: ğŸ”„ *re-implement*, ğŸ—‘ï¸ *discard*, â™» *reuse algorithm but Lean-ify*.

---

## 3. Open Questions / Risks

1. **Tokenisation vs. Lean parser** â€” Do we really need a separate scanner?  Lean already tokenises input, but its token categories differ (treats `\` as escape).  Quick prototype suggests that recognising Litex commands directly as Lean *identifiers* is awkward.  The alternative is *raw string DSL*: `golitex| ... |`.  Decision postponed until after milestone M1 prototype.
2. **Unicode & catcodes** â€” Original Go lexer deals with TeXâ€™s category codes.  Leanâ€™s Unicode support is strong, but catcodes are not.  Might need custom pre-processing pass.
3. **Performance** â€” Pure-Lean scanner may be slower than Go; acceptable for short docs but large books?
4. **Error reporting** â€” Need mapping from generated Lean syntax positions back to original .ltx byte offsets for IDE diagnostics.
5. **Threading resources** â€” Leanâ€™s `IO` is single-threaded; PDF render calling `lualatex` will be external process anyway, fine.

---

## 4. Next Steps

1. Prototype `golitex| ... |` quasi-quoter (Phase 3).
2. Define `Token` inductive & minimal scanner to feed later passes (if we choose external scanner path).
3. Spike: write simple document & render via `lualatex` Lake task (Phase 5 preview).

---
*(End of file)*
