import Lean

/-!
Golitex custom lint rules.

Currently implemented rules:

1. **Missing doc strings** – every public constant in the `Golitex` or
   `Leantix` namespace must have a docstring.

2. **Forbidden `unsafe` definitions** – except for whitelisted namespaces.

Future work: namespace-open usage analysis, syntax-quote anti-patterns, etc.
-/

namespace Golitex.Lint

open Lean

structure LintResult where
  ok     : Bool
  output : String

private def isProjectName (n : Name) : Bool :=
  n.getPrefix.isPrefixOf `Golitex || n.getPrefix.isPrefixOf `Leantix

/-!
Rule 1: Every public constant must carry a docstring.
-/
def checkDocstrings : CoreM LintResult := do
  let env ← getEnv
  let mut missing : Array Name := #[]
  for (n, c) in env.constants do
    if !isProjectName n then
      continue
    if (env.getDocString? n).isNone then
      -- ignore autogenerated names that have a `_` component at the end
      if n.components.all (fun comp => !comp.toString.startsWith "_") then
        missing := missing.push n
  if missing.isEmpty then
    pure { ok := true, output := "Docstring check passed" }
  else
    let msgs := String.intercalate "\n" <| missing.toList.map (fun n => s!"[lint][doc] missing docstring for {n}")
    pure { ok := false, output := msgs }

/-!
Rule 2: Ensure no `unsafe` definitions outside a whitelist.
-/
def allowedUnsafePrefixes : List Name := [`Golitex.Unsafe]

def checkUnsafe : CoreM LintResult := do
  let env ← getEnv
  let mut offenders : Array Name := #[]
  for (n, c) in env.constants do
    if !isProjectName n then
      continue
    match c with
    | ConstantInfo.defnInfo d =>
        if d.safety == .unsafe then
          let allowed := allowedUnsafePrefixes.any fun p => p.isPrefixOf n
          if !allowed then offenders := offenders.push n
    | _ => pure ()
  if offenders.isEmpty then
    pure { ok := true, output := "Unsafe check passed" }
  else
    let msg := String.intercalate "\n" <| offenders.toList.map (fun n => s!"[lint][unsafe] forbidden `unsafe` def {n}")
    pure { ok := false, output := msg }

def runAll : CoreM Bool := do
  let results ← [checkDocstrings, checkUnsafe].mapM id
  for r in results do
    IO.println r.output
  pure <| results.all (·.ok)

end Golitex.Lint
